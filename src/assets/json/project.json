{
  "items": [
    {
      "id": 5,
      "name": "사이드픽(Side-Peek)",
      "summary": "사이드 프로젝트 아이디어 및 결과물을 공유하는 커뮤니티 서비스입니다.",
      "date": "2024.01 ~ (진행중)",
      "scale": "백엔드 3명 / 프론트엔드 5명",
      "process": [
        [
          "Git/Github 기반 협업 환경 구축",
          "구성원이 여러명이고 구현해야할 기능이 많았기 때문에, 각 기능들이 서로 영향을 받지 않도록 설계하고 Git Flow 전략을 반영하여 각각의 기능을 개발했습니다."
        ],
        [
          "Notion, Github Projects 개발 과정 공유 및 결과물 기록",
          "API 명세서, 와이터 프레임, 회의 기록 등을 Notion에 정리하고, Github Projects에는 프로젝트 진행 과정을 기록했습니다."
        ]
      ],
      "role": [
        [
          "프로젝트 게시글 생성/수정/삭제 API 구현",
          "비즈니스 로직에 맞는 프로젝트 게시글/댓글 정보를 생성하고 수정하는 API와 이를 구현하기 위한 기술 스택, 멤버 검색, 이미지 업로드 등 부가적인 API를 구현했습니다."
        ],
        [
          "이미지 업로드 API 구현",
          "AWS S3 서비스를 사용할 수 있는 환경을 구성하고, 저장할 이미지들을 저장하는 API를 구현했습니다. 테스트 환경에서는 외부 의존성이 생기지 않도록 Mocking을 통해 테스트 환경을 구성했습니다."
        ],
        [
          "서버에서 발생하는 즉각적인 예외 인지를 위한 Sentry, Slack 알림 기능 구현",
          "개발용/운영용 환경 서버에 발생하는 예외를 즉각적으로 인지하기 위해 Sentry와 Slack을 서버에 연동하는 기능을 구현했습니다."
        ]
      ],
      "category": ["Web", "Backend"],
      "keyword": [
        "Java 17",
        "Spring Boot 3.2.2",
        "JaCoCo",
        "Swagger",
        "Docker",
        "MySQL 8.3.0",
        "AWS S3"
      ],
      "trouble": [
        [
          "테스트 코드에서 Entity, Dto 생성/저장 로직 중복 발생, Fixture 제공 클래스 구현으로 중복 개선",
          "생성자에 들어갈 값을 중복으로 정의하는 상황이었습니다. 이 때문에 코드양이 많아져서 신속하고 간단하게 작성해야 하는 테스트 코드를 읽고 작성하는 데에 어려움이 있었습니다. 각각 테스트 클래스에서 중복되는 코드를 찾아서 테스트 환경 전역에서 사용할 수 있는 static 메서드로 정의하고 이러한 메서드를 제공하는 테스트 Fixture 제공 클래스를 구현하여 팀원들에게 사용법을 공유했습니다."
        ],
        [
          "복잡하고 많은 기능으로 인해 정교한 테스트 케이스 작성 어려움, JaCoCo 도입으로 개선",
          "JaCoCo에서 제공하는 Code Coverage Reports를 통해 더욱 정교한 테스트를 작성할 수 있는 환경을 조성했습니다. 또한 Build 시에 라인 커버리지를 넘기지 못하면 Build가 안되도록 설정하여 기능 구현 때마다 확인할 수 있는 환경을 조성했습니다."
        ],
        [
          "Slack 예외 알림 도입 후 응답 속도 저하 문제 발생 및 개선 시도",
          "예외 핸들러에 Slack 알림을 추가하고, 이를 통해 서버에서 발생하는 예외를 즉각적으로 인지할 수 있도록 했습니다. 하지만 이로 인해 예외 핸들러 메서드에 Slack API 요청이 더해져서 응답 속도가 저하되는 문제가 발생했습니다. 이를 해결하기 위해 비동기 방식으로 Slack 알림을 보내는 방식으로 보내는 것을 고려하게 되었습니다."
        ]
      ],
      "result": "🚀 데브코스 최종 프로젝트",
      "url": "https://github.com/side-peek/sidepeek_backend"
    },
    {
      "id": 4,
      "name": "OOTW(Outfit-Of-The-Weather)",
      "summary": "날씨에 맞는 코디를 공유하는 커뮤니티 서비스입니다. 사용자가 현재 위치의 날씨를 확인하고, 해당 날씨에 맞는 옷차림을 아바타로 꾸며 공유할 수 있습니다.",
      "date": "2023.12 ~ 2024.01(1개월)",
      "scale": "백엔드 3명",
      "process": [
        [
          "Git/Github 기반 협업 환경 구축",
          "Notion, Github Projects를 이용하여 개발 과정을 공유하고 결과물을 기록해왔습니다."
        ],
        [
          "CheckStyle 도입을 통한 코드 스타일 관리",
          "코드 스타일 통일을 위해 CheckStyle을 도입하고, CI 과정에서 코드 스타일을 체크하여 통일성을 유지했습니다."
        ],
        [
          "JMeter를 이용하여 API 부하 테스트 진행",
          "API의 부하 테스트를 진행하여, 서버의 성능을 확인하고, 성능을 개선할 수 있는 환경을 조성했습니다."
        ]
      ],
      "role": [
        [
          "기상청 API 기반 날씨 정보 조회 API 구현",
          "OpenFeign을 통해 기상청 초단기예보 API에서 현재 위치의 날씨 정보를 불러오고, @JsonSerializer를 이용해 필요한 데이터만 추출했습니다. 또한 테스트 환경에서는 외부 의존성이 생기지 않도록 기상청 API의 가상의 응답을 작성하고 Mocking을 통해 테스트 환경을 구성했습니다."
        ],
        [
          "날씨 기반 코디 공유 게시글 CRUD API구현",
          "코디 게시글을 생성, 조회, 수정, 삭제하는 API를 구현했습니다. 코디 게시글을 저장할 때에는 기상청 단기예보 API를 이용해 그날의 일교차 데이터를 함께 저장했습니다. 게시글의 일교차 데이터와 오늘의 날씨 정보를 연관지어 현재 기온에 적합한 코디 게시글을 조회할 수 있도록 구현했습니다."
        ]
      ],
      "category": ["Web", "Backend"],
      "keyword": [
        "Java 17",
        "Spring Boot 3.2.2",
        "CheckStyle",
        "RestDocs",
        "Docker",
        "MySQL 8.3.0",
        "JMeter"
      ],
      "trouble": [
        [
          "날씨 정보 조회 API 응답 시간이 길어지는 문제 해결 시도",
          "기상청 API의 응답 시간이 길어지는 문제가 발생했습니다. 매 호출마다 외부 API를 불러오는 것에서 많은 시간이 소요된다는 것을 알게 되었고 이를 호출 횟수를 줄이고자 Redis 도입을 고민해보았습니다."
        ],
        [
          "코디 공유 게시글 목록 조회 API에서 커서 기반 페이지네이션 시도",
          "JMeter 부하 테스트 결과로 코디 공유 게시글 목록 조회에서 가장 많은 시간이 소요된다는 것을 알게 되었습니다. 모든 게시글 데이터를 한 번에 조회하기 때문에 많은 서버에서 메모리가 필요하게 되었고 이 때문에 서버가 느려진다는 것을 알게 되었습니다. 이후 커서 기반 페이지네이션을 이용하여 필요한 만큼의 데이터를 불러오는 것을 고민하게 되었습니다."
        ],
        [
          "테스트 실행 속도 개선 시도",
          "Build를 위해 실행해야할 테스트 케이스가 대략 200개를 넘어가면서 테스트 실행 속도가 저하되는 것을 인지했습니다. 원인을 찾아본 결과 각각의 테스트 클래스는 각각 다른 Bean의 의존성을 주입받고 있었는데 이는 @SpringBootTest에서 새로운 Context를 만들어낸다는 것을 알게 되었습니다. 이 때문에 속도가 느려진 것을 인지하고 테스트 환경을 하나의 @TestConfiguration으로 통합하여 개선해보려고 고민했습니다."
        ]
      ],
      "result": "🚀 데브코스 백엔드 팀 프로젝트",
      "url": "https://github.com/backendoori/ootw-backend"
    },
    {
      "id": 3,
      "name": "How Cook?",
      "summary": "냉장고 속 남은 재료들이나 마트 영수증을 촬영하여 사진애서 인식한 재료들로 만들 수 있는 레시피를 추천 받고, 검색할 수 있도록 도와주는 서비스입니다. ",
      "date": "2022.01 ~ 2022.06(6개월)",
      "scale": "소프트웨어전공 학부생 4명",
      "process": [
        [
          "그라운드룰 설정 및 스프린트 도입",
          "더 나은 팀 빌딩과 원활한 의견 공유를 위해, 각자의 개발 경험을 공유하고 프로젝트 기획 전에 소통, 진행 계획과 관련한 그라운드 룰을 설정했습니다. 또한, Backlog 작성 후, 일주일 단위의 스프린트를 도입하고 Slack으로 매일 진행상황을 기록했습니다. 이를 통해 개발 과정에서 생긴 문제점, 개선점을 더 빠르게 공유하고, 다함께 고민하여 신속하게 해결할 수 있는 환경을 조성할 수 있었습니다."
        ],
        [
          "Use Case 구상 및 프로토타입 설계",
          "서비스 사용 흐름을 정리하고자 Use Case를 구상하고 Figma를 이용하여 프로토타입을 제작했습니다. 이를 통해 더욱 구체적으로 사용자 입장에서 서비스를 바라볼 수 있었고 Use Case를 더욱 구체화하는 데 많은 도움이 되었습니다. 또한 Backlog에 정리한 작업들이 정말 필요한 작업인지 다시 한 번 검증하며 더욱 효율적으로 프로젝트를 진행할 수 있었습니다."
        ],
        [
          "Git/Github 기반 협업 환경 구축",
          "구성원이 여러명이고 구현해야할 기능이 많았기 때문에, 각 기능들이 서로 영향을 받지 않도록 설계하고 Git Flow 전략을 반영하여 각각의 기능을 개발했습니다. 또한 기능별 진행과정을 확실히 알 수 있도록 커밋 컨벤션을 설정했습니다. 개발 도중 발생한 문제점과 개선점은 Github Issue를 통해 기록했습니다. git conflict 발생이 예상되는 상황에는 Live Share를 이용하여 실시간으로 코드를 공유하고, 서로 코드를 리뷰하며 개선점을 공유했습니다. 이를 통해 팀원들과의 협업을 더욱 원활하게 진행할 수 있었습니다."
        ],
        [
          "Notion, Github Wiki로 개발 과정 공유 및 결과물 기록",
          "API 명세서, 와이터 프레임, 회의 기록 등을 Notion에 정리하고, Github Wiki에는 프로젝트 진행 과정을 기록했습니다. 이를 통해 프로젝트 진행 과정을 더욱 체계적으로 기록할 수 있었고, 팀원들과 공유할 수 있었습니다. "
        ]
      ],
      "role": [
        [
          "유저, 레시피 CRUD API 구현 및 API 테스트 환경 조성",
          "Express 기반으로 API Layer를 3단계(controller, service, repository)로 나누고 TypeORM을 사용하여 유저, 레시피 CRUD API를 구현했습니다. 또한 Postman과 REST client를 이용하여 API 테스트 환경을 조성했습니다."
        ],
        [
          "재료 이미지/영수증 속 재료 리스트 반환 API 구현 및 배포",
          "재료 이미지/영수증 속 재료 리스트를 반환하는 API를 구현하고, Heroku로 배포했습니다. 클라이언트에서 받은 이미지를 디코딩하여 인공지능 모델에 넣어 재료 리스트를 반환합니다. Python 기반 인공지능 모델을 이용하여 결과를 반환하는 API는 두 가지 기능만 필요했기 때문에 빠르고 가볍게 구축할 수 있는 FastAPI를 사용했습니다."
        ],
        [
          "재료 이미지 및 영수증 전송 후 재료 리스트 결과 페이지 이동 구현",
          "React를 기반으로 재료 이미지와 영수증 이미지를 전송하여 분석된 재료 리스트를 요청하고, 다른 페이지에서도 재료 리스트를 이용하기 위해 Recoil을 통해 결과를 저장합니다. 응답 후 페이지를 이동하여 저장된 재료 리스트를 띄워주는 기능을 구현했습니다. 구현한 컴포넌트의 재사용성을 높이기 위해 Styled-Components를 사용했습니다. 또한 Media Query를 이용하여 사용자 기기의 크기에 따라 레이아웃을 변경할 수 있도록 반응형 웹을 구현했습니다."
        ]
      ],
      "category": ["Web", "Frontend", "Backend"],
      "keyword": ["React", "Express", "FastAPI", "Heroku", "Git"],
      "trouble": [
        [
          "재료 이미지, 영수증 속 재료 리스트 반환 API 요청 후 지연시간 발생",
          "재료 리스트를 받아오는 동안 인공지능 모델 연산 시간으로 인해 지연시간이 발생했습니다. async/await 비동기 처리를 이용하여 요청 이후 응답을 받아올 때까지 기다리도록 설정하고, 사용자 경험을 개선하기 위헤 Recoil Atom으로 응답 반환 상태를 확인하고 응답을 기다리는 동안에만 로딩 모달이 보이도록 설정했습니다."
        ],
        [
          "Heroku 배포 후 메모리 초과 발생",
          "재료 이미지 및 영수증 속 재료 리스트 반환 API를 Heroku에 배포한 이후 요청이 많아질수록 5** 응답 코드가 발생하는 것을 확인했습니다. Heroku를 무료 버전으로 사용하면서 적은 메모리 설정 때문에 발생한 문제였습니다. 이를 통해 적절한 메모리 설정의 중요성을 깨달았습니다."
        ]
      ],
      "result": "🏆 교내 캡스톤디자인 최종발표회 최우수상(1위), SW인재페스티벌 우수작품관 부스 운영",
      "url": "https://github.com/kookmin-sw/capstone-2022-10"
    },
    {
      "id": 2,
      "name": "CarKeeper(카키퍼)",
      "summary": "차박 중 차량 외부 외부인/야생동물(이하, 대상)의 접근, 차량 내부 유해가스 위험 상황을 감지하여 사용자에게 알려주는 서비스 입니다. 사용자가 차박 중 자주 일어나는 위험 상황으로부터 신속하게 대응할 수 있도록 도와줌으로써, 안전한 차박을 제공합니다.",
      "date": "2022.06 ~ 2022.12(6개월)",
      "scale": "임베디드 SW 학술 동아리원 4명",
      "category": ["IoT", "Cloud", "Mobile"],
      "keyword": [
        "Flutter",
        "Flask",
        "Firebase",
        "Raspberry Pi 4",
        "Pi Camera",
        "Ultrasonic Sensor",
        "Pan Tilt Motor",
        "Arduino",
        "MQTT"
      ],
      "process": [
        [
          "Backlog 작성 후 스프린트 도입",
          "구현할 기능을 정리하기 위해 Backlog를 작성했습니다. 이를 통해 프로젝트 진행 과정에서 생긴 문제점, 개선점을 더 빠르게 공유하고, 다함께 고민하여 신속하게 해결할 수 있는 환경을 조성할 수 있었습니다. 또한 일주일 단위의 스프린트를 도입하고 Slack으로 매일 진행상황을 기록했습니다."
        ],
        [
          "Use Case 구상 및 프로토타입 설계",
          "서비스 사용 흐름을 정리하고자 Use Case를 구상하고 Figma를 이용하여 프로토타입을 제작했습니다. 이를 통해 더욱 구체적으로 사용자 입장에서 서비스를 바라볼 수 있었고 Use Case를 더욱 구체화하는 데 많은 도움이 되었습니다. 또한 Backlog에 정리한 작업들이 정말 필요한 작업인지 다시 한 번 검증하며 더욱 효율적으로 프로젝트를 진행할 수 있었습니다."
        ]
      ],
      "role": [
        [
          "영상 스트리밍 API, 웹소켓 서버 구현",
          "라즈베리파이에 연결된 카메라로 촬영되는 실시간 영상을 HTTP 프로토콜로 전송하는 Flask API를 개발했습니다. 영상을 외부망에서도 확인할 수 있도록 포트포워딩도 진행했습니다. 또한 Websocket을 이용하여 실시간 영상을 모바일 앱으로 안정적으로 볼 수 있도록 구현했습니다."
        ],
        [
          "실시간 영상 확인 모바일 애플리케이션 페이지 구현",
          "Websocket으로 전송받은 실시간 영상을 Flutter 애플리케이션에서 확인할 수 있도록 페이지를 구현했습니다. 스트리밍 페이지 자체에서는 상태관리 라이브러리를 사용하지 않고, 기본 State 기능을 통해 웹소켓 연결 여부만을 관리 했습니다. 웹소켓 연결은 web_socket_channel 라이브러리를 이용하여 구현했습니다. 또한 StreamBuilder를 이용해 연속적으로 받은 영상들을 디코딩하고 화면에 띄우는 작업을 진행했습니다."
        ],
        [
          "실시간 초음파 센서 데이터와 실시간 영상 속 객체의 좌표 전송 기능",
          "MQTT 프로토콜을 이용하여 라즈베리파이에 연결된 초음파 센서로부터 수집한 대상과 차량의 실시간 거리를 '대상 위치 및 접근 감지' 서버로 전송합니다. 또한 해당 서버에서 계산한 실시간 영상 속 대상의 좌표를 다시 라즈베리파이로 전송합니다."
        ],
        [
          "대상 좌표 데이터 기반 원격 카메라 각도 실시간 제어 기능",
          "카메라가 연결된 라즈베리파이에서는 MQTT 프로토콜로 대상의 실시간 좌표를 수신하고, 이를 기반으로 두 개의 서보모터(각각 상/하, 좌/우 조절)를 제어하여 카메라의 각도가 대상을 트래킹하도록 구현했습니다. 이를 통해 카메라와 함께 움직이는 초음파 센서도 더욱 정확하게 대상과 차량 사이의 거리를 측정할 수 있었습니다."
        ],
        [
          "Firebase Firestore 이벤트 감지 설정 및 모바일 메시지 자동 전송 기능",
          "Firebase의 Cloud Function 기능으로 Firestore에서 '대상 접근 판단 변수'가 True로 변하거나, '유해가스 농도'가 주의/위험 수준으로 변하는 경우를 감지합니다. 이벤트가 감지되면 Cloud Function이 작동하여 Cloud Messaging을 이용하여 메시지를 자동으로 생성하고 모바일 애플리케이션으로 전송합니다."
        ]
      ],
      "trouble": [
        [
          "좌표 값에 따른 서보모터 제어 방식 개선",
          "초기에는 매 프레임마다 [(영상 프레임의 중앙 x, y 좌표) - (대상 박스의 중앙 x, y 좌표)] 값에 '비례'하게 서보 모터 제어 각도를 설정했습니다. 하지만 대상이 빠르게 움직이고, 서보모터 제어 시간도 고려해야하기 때문에 해당 방식의 한계를 깨달았습니다. 이후 좌표 데이터에서 '이동 방향'만 추출하고 프레임마다 '단위 각도'만큼 움직이도록 설정하였습니다. 또한 정확한 서보모터 제어를 위해 제어하는 동안에는 프로그램을 일정 시간동안 Sleep 하도록 설정했습니다. "
        ]
      ],
      "result": "🏆 제 20회 임베디드 소프트웨어 경진대회 자동차/모빌리티 부문 최우수상 (부문 1위)",
      "url": "https://github.com/KOBOTBOARD-11/2022ESWContest_mobility_6017"
    },
    {
      "id": 3,
      "name": "Booriya!(불이야!)",
      "summary": "화재 발생 시 건물 CCTV 영상을 기반으로 건물 관리자 및 출동 중인 소방관들에게 실시간으로 화재 현장 정보(초기 화재 발생 장소, 구조 대상자 등)를 제공해, 화재 진압과 인명 구조에 도움을 줄 수 있는 모바일 어플리케이션 서비스입니다.",
      "date": "2022.06 ~ 2022.12(6개월)",
      "scale": "임베디드 SW 학술 동아리원 4명",
      "process": [
        [
          "Backlog 작성 후 스프린트 도입",
          "구현할 기능을 정리하기 위해 Backlog를 작성했습니다. 이를 통해 프로젝트 진행 과정에서 생긴 문제점, 개선점을 더 빠르게 공유하고, 다함께 고민하여 신속하게 해결할 수 있는 환경을 조성할 수 있었습니다. 또한 일주일 단위의 스프린트를 도입하고 Slack으로 매일 진행상황을 기록했습니다."
        ],
        [
          "Use Case 구상 및 프로토타입 설계",
          "서비스 사용 흐름을 정리하고자 Use Case를 구상하고 Figma를 이용하여 프로토타입을 제작했습니다. 이를 통해 더욱 구체적으로 사용자 입장에서 서비스를 바라볼 수 있었고 Use Case를 더욱 구체화하는 데 많은 도움이 되었습니다. 또한 Backlog에 정리한 작업들이 정말 필요한 작업인지 다시 한 번 검증하며 더욱 효율적으로 프로젝트를 진행할 수 있었습니다."
        ]
      ],
      "role": [
        [
          "영상 스트리밍 API, 웹소켓 서버 구현",
          "라즈베리파이에 연결된 카메라로 촬영되는 실시간 영상을 HTTP 프로토콜로 전송하는 Flask API를 개발했습니다. 영상을 외부망에서도 확인할 수 있도록 포트포워딩도 진행했습니다. 또한 Websocket을 이용하여 실시간 영상을 모바일 앱으로 안정적으로 볼 수 있도록 구현했습니다."
        ],
        [
          "실시간 영상 확인 모바일 애플리케이션 페이지 구현",
          "Websocket으로 전송받은 실시간 영상을 Flutter 애플리케이션에서 확인할 수 있도록 페이지를 구현했습니다. 스트리밍 페이지 자체에서는 상태관리 라이브러리를 사용하지 않고, 기본 State 기능을 통해 웹소켓 연결 여부만을 관리 했습니다. 웹소켓 연결은 web_socket_channel 라이브러리를 이용하여 구현했습니다. 또한 StreamBuilder를 이용해 연속적으로 받은 영상들을 디코딩하고 화면에 띄우는 작업을 진행했습니다."
        ],
        [
          "Firebase Firestore 이벤트 감지 설정 및 모바일 메시지 자동 전송 기능",
          "Firebase의 Cloud Function 기능으로 Firestore에서 '초기 화재 감지 변수'나 '구조인원 감지 변수'가 True로 변하는 경우를 감지합니다. 이벤트가 감지되면 Cloud Function이 작동하여 Cloud Messaging을 이용하여 메시지를 자동으로 생성하고 모바일 애플리케이션으로 전송합니다."
        ]
      ],
      "category": ["IoT", "Cloud", "Mobile"],
      "keyword": ["Flutter", "Flask", "Firebase", "JavaScript", "Raspberry Pi"],
      "trouble": [
        [
          "로컬 서버 → 서버리스 클라우드 서비스(Google Cloud Functions) 전환으로 개선된 이벤트 감지 시간",
          "YOLO v5 기반 로컬 서버에서는 다른 이벤트들(영상 처리, 대상 좌표 구하기 등)도 처리를 해야하기 때문에, Loop 문을 이용하여 실시간 데이터 모니터링을 하게되면 딜레이가 많이 생기는 상황이었습니다. 딜레이가 생기는 이유는 한 서버에 연산량이 많아져서 발생하는 것이라고 생각했고, 기능을 분리하고자 실시간 데이터 모니터링 기능은 클라우드 서비스를 이용했습니다. 단일 이벤트 목적으로 이용하는 Google Cloud Functions를 사용하면서 이벤트 감지 반응 속도를 높일 수 있었으며, 간편하게 기능을 구현함으로써 개발 시간을 단축할 수 있었습니다. 다른 서비스와의 높은 연동성으로 자동 메시징 기능도 한 번에 해결할 수 있었습니다."
        ]
      ],
      "result": "🏆 제 16회 공개SW 개발자 대회(사회문제형) 본선 진출 및 우수작 선정",
      "url": "https://github.com/KOBOTBOARD-11/OSS_2022"
    },
    {
      "id": 3,
      "name": "Object tracking & laser pointing system",
      "summary": "테니스 공을 트래킹하며 테니스 공의 위치를 레이저로 포인팅하는 프로젝트입니다.",
      "date": "2022.09 ~ 2022.12(3개월)",
      "scale": "개인",
      "process": [
        [
          "Backlog 작성 후 스프린트 도입",
          "구현할 기능을 정리하기 위해 Backlog를 작성했습니다. 이를 통해 프로젝트 진행 과정에서 생긴 문제점, 개선점을 더 빠르게 공유하고, 다함께 고민하여 신속하게 해결할 수 있는 환경을 조성할 수 있었습니다. 또한 일주일 단위의 스프린트를 도입하고 Slack으로 매일 진행상황을 기록했습니다."
        ],
        [
          "Use Case 구상 및 프로토타입 설계",
          "서비스 사용 흐름을 정리하고자 Use Case를 구상하고 Figma를 이용하여 프로토타입을 제작했습니다. 이를 통해 더욱 구체적으로 사용자 입장에서 서비스를 바라볼 수 있었고 Use Case를 더욱 구체화하는 데 많은 도움이 되었습니다. 또한 Backlog에 정리한 작업들이 정말 필요한 작업인지 다시 한 번 검증하며 더욱 효율적으로 프로젝트를 진행할 수 있었습니다."
        ]
      ],
      "role": [
        [
          "HSV 필터 기반으로 이미지에서 테니스 공 반지름 및 중앙 좌표 추출",
          "테니스 공의 색상(연두색) 범위를 정하고 HSV 필터를 통해 카메라 영상에서 테니스 공 색상에 해당되는 부분을 분리합니다. 그 결과에서 minEnclosingCircle() 메서드를 이용해 테니스 공의 반지름과 중앙좌표를 추출했습니다."
        ],
        [
          "테니스 공 트래킹 및 포인팅 기능 구현",
          "RPi.GPIO 라이브러리를 이용하여 테니스 공의 중앙 좌표를 기준으로 팬틸트 모터를 제어합니다. 또한 레이저가 테니스 공의 중앙을 포인팅하도록 구현했습니다."
        ]
      ],
      "category": ["OpenCV", "Embedded System"],
      "keyword": [
        "OpenCV",
        "RPi.GPIO",
        "Pigpio",
        "Raspberry Pi 4",
        "Pi Camera",
        "Pan Tilt Motor(MG90S Servo Motor)"
      ],
      "trouble": [
        [
          "부드러운 서보모터 제어를 위해 pigpio library 사용",
          "RPi.GPIO에서 Pigpio로 변경 후 지터링을 개선하여 더욱 부드럽게 테니스 공을 트래킹하도록 구현했고, 레이저 포인팅도 더욱 정확하게 할 수 있었습니다."
        ]
      ],
      "result": "🏫 2022년도 2학기 임베디드시스템설계 과목 기말 프로젝트",
      "url": "https://github.com/Sehee-Lee-01/2022_2_ESD/tree/main/FinalProject"
    }
  ]
}
